OT_UdpCapture 메인 소스
=========================================

소스코드
-----------
.. code::

   # -*- coding: utf-8 -*- 
   import time
   import pcap 
   import dpkt
   import OT_ShmLib as ot
   from ctypes import *
   import datetime
   import struct
   import sys 

- ``# -*- coding: utf-8 -*-`` 리눅스일 경우
- ``import OT_ShmLib as ot`` 공유메모리

.. code::
   
   class OT_UdpCapture:
      def __init__(self):
         pass  
      def capture(self):
         nId = 1
         nOffset = 0
         nSize = 2000
         data = (c_byte*nSize)()
         start = time.time()
         filetime = time.strftime('%H_%M_%S', time.localtime(time.time()))

      
- ``nId`` 은 공유메모리 소스코드의 변수이며 한 덩어리를 의미(한덩어리=Shm_COL_SIZE(2000byte)*SHM_ROW_SIZE(100)) 총 3개의 nID 
- ``nOffset`` 은 공유메모리 소스코드 변수이며 한 덩어리 안에서 얼마나 떨어져 있는가를 의미
- ``nSize`` 은 은 공유메모리 소스코드 변수이며 패킷 한덩어리(=Shm_COL_SIZE)
- ``def capture(self):`` 은 캡쳐와 pcap파일로 저장하는 함수
- ``start=time.time()`` 프로그램 시작시간
- ``filetime`` 은 파일이름 저장시 파일이름이 되는 24시간 기준 시_분_초


.. code::

   #..
         sniffer = pcap.pcap(name=None, promisc=True, immediate=True)

- ``name=None`` 디바이스 이름 None을 두면 디폴트 값이 들어가게 되고 작은 따옴표 안에 직접 디바이스 명을 넣을수 있음
- ``promisc=True`` 프리큐어스모드(무차별) True는 모든 패킷을 캡쳐 가능
- ``immediate=True`` immediate 옵션 해당 옵션을 True로 설정하여 지연문제를 없앨수 있음
- ``timeout_ms=50`` 타임아웃시간 ms단위로 50이면 0.05초로 설정

.. code::
    
    #.  
         sniffer.setfilter('udp and port 5353')

현재 상태: UDP 필터 포트5353필터(쓰지 않아도 됨)

.. code::
   
   #..   
         n=0
         writer = dpkt.pcap.Writer(open(filetime+".pcap", 'wb+')) 

- ``n`` 은 패킷을 셀 수 있는 변수
- ``writer`` 은 dpkt를 이용하여 pcap파일을 작성함

.. code::
   
   #..   
         for ts, pkt in sniffer:
            writer.writepkt(pkt, ts)
            n=n+1

- ``sniffer`` 객체의 첫번 째 값은 ``timestamp** , 두번째값은  ``packet`` 으로 반복문을 돌겠다는 의미
- 이후 pkt[idx] 형식으로 네트워크 패킷의 특정 위치 인덱스 값을 가져올 수 있음
- ``writer.writepkt(pkt, ts)`` pcap파일에 저장
- ``n`` 은 패킷을 카운트하는 변수이며 ``for ts, pkt in sniffer:`` 하위에


.. code-block::
   
   #..
             """print('Dst MAC - ', end='', flush=True) #프레임을 수신할 맥주소정보-이더넷 헤더
            print(':'.join('%02X' % i for i in pkt[0:6])) #패킷의 0번부터 5번 바이트까지 출력 (Str(hex))
            print('Src MAC - ', end='', flush=True)#프레임을 송신할 호스트의 맥주소 정보-이더넷헤더
            print(':'.join('%02X' % i for i in pkt[6:12])) #패킷의 6번부터 11번 바이트까지 출력
            print(':'.join('%02X' % i for i in pkt[:]))
            print(str(pkt))"""

등 을 이용할 수 있음

.. code-block:: 
   
   #..
            if (''.join('%02x' % i for i in pkt[42:43])) == "32":
                if nOffset < 200000:
                  print("nId", nId, "nOffset", nOffset)
                  testVal=''.join('%02x' % i for i in pkt[:])
                  testVal=testVal.encode()
                  print(testVal)
                  struct.pack_into('2000s', data, 0, testVal)
                  shm.WriteShm(nId, byref(data), nOffset, nSize)
                  nOffset = nOffset+2000

- ``if (''.join('%02x' % i for i in pkt[42:43]))=="32":`` 42번자리 str(hex) 값이 32 즉 아스키코드로 변환시 2일경우 공유메모리에 저장하는 조건
- ``if nOffset < 200000:`` 한덩어리=Shm_COL_SIZE(2000byte)*SHM_ROW_SIZE(100) 기준으로 저장
- ``testVal=''.join('%02x' % i for i in pkt[:])`` 공유메모리에 저장할 변수는 str(hex) 형태
- ``testVal=testVal.encode()`` byte형태로 변환
- ``struct.pack_into`` struck(패킹된 바이너리 데이터로 바이트열을 해설하는 표준 라이브러리) 함수로  ``struct.pack_into(format, buffer, offset, v1, v2, ...)`` 포맷 문자열 format에 따라 값 v1, v2, ... 를 패킹하고 패킹 된 바이트열을 쓰기 가능한 버퍼 buffer에 offset 위치에서부터 사용
- ``shm.WriteShm(nId, byref(data), nOffset, nSize)`` OT_ShmLib 공유메로리 함수로써 메모리를 쓰는 함수
- ``nOffset = nOffset+2000`` 2000byte 기준으로 공유메로리를 작성

.. code-block:: 
   
   #..
            else:
               if nId<3:
                  nId = nId+1
                  nOffset=0
               else:
                  nId=1

- 공유메모리 함수 기준으로 차례로 공유메모리로 작성


.. code::
   
   #..
            if n==1000:
               print("completion")
               writer.close()
               break

패킷이 1000번이카운터가 되면 파일은 닫히며 무한루프도 종료

.. code::

   if __name__=='__main__':
      shm=ot.OT_ShmLib()
      shm.CreateShm()
      udp=OT_UdpCapture()
      udp.capture()
      print("time :", time.time() - start)

- ``shm.CreateShm()`` 공유메모리를 작성하기전 만드는 함수
- print는 클래스 함수를 사용하며 종료되는 시간과 처음시간과 차이로 프로그램 시간을 구함


참고 함수
================

**pcap파일을 저장해서 txt파일로 변환 txt파일을 josn파일로 변환하는 함수**

.. code::
   
   import json
   import dpkt
   def json_format():
      json_file = open(filetime+".txt", 'w') 
      with open(filetime+".pcap", 'rb') as f:
         pcap = dpkt.pcap.Reader(f)
         for ts, buf in pcap:
            json_file = open(filetime+".txt", 'a')
            eth = dpkt.ethernet.Ethernet(buf)
            buf=str(':'.join('%02X' % i for i in buf[:])+"\n"+repr(eth)+"\n\n")
            print(buf)
            json_file.write(buf)
            json_file.close()
      file = open(filetime+".txt", "r")
      strings = file.readlines()
      with open(filetime+".json", "w") as json_file:
      json.dump(strings, json_file)

pcap -> txt -> json 변환


총 코드
======================
.. code::
  
   import time
   import pcap
   import dpkt
   import OT_ShmLib as ot
   from ctypes import *
   import datetime
   import struct
   import sys
   
   class OT_UdpCapture():
      def __init__(self):
         pass
      def capture(self):
         nId = 1
         nOffset = 0
         nSize = 2000
         data = (c_byte*nSize)()
         start = time.time()
         filetime = time.strftime('%H_%M_%S', time.localtime(time.time()))
         sniffer = pcap.pcap(name=None ,promisc=True, immediate=True)
         sniffer.setfilter("udp")
         n=0
         writer = dpkt.pcap.Writer(open(filetime+".pcap", 'wb+'))
         for ts, pkt in sniffer:
               writer.writepkt(pkt, ts)
               n=n+1
               print(pkt)
               if (''.join('%02x' % i for i in pkt[42:43])) == "32":
                  #print("----------")
                  if nOffset < 200000:
                     print("nId", nId, "nOffset", nOffset)
                     testVal=''.join('%02x' % i for i in pkt[:])
                     testVal=testVal.encode()
                     print(testVal)
                     struct.pack_into('2000s', data, 0, testVal)
                     shm.WriteShm(nId, byref(data), nOffset, nSize)
                     nOffset = nOffset+2000
                  else:
                     if nId<3:
                           nId = nId+1
                           nOffset=0
                     else:
                           nId=1
               if n==100:
                  print("completion")
                  writer.close()
                  print("time :", time.time() - start)
                  break
               
         
   if __name__=='__main__':
      shm=ot.OT_ShmLib()
      shm.CreateShm()
      udp=OT_UdpCapture()
      udp.capture()

